\subsection{Jetset}

The Jetset system uses symbolic execution to infer what behavior firmware expects from a target hardware device.
It recovers traces of the expected I/O behavior, and then generates device models for hardware peripherals in C, allowing the an analyst to boot the firmware in an emulator.
Jetset was applied to 13 firmware images, the most complex of which were a Feeder Protection Relay, the Communication Management Unit of a Boeing 737, and a Raspberry Pi.
The emulated firmware image also facilitates fuzz-testing, and a custom, architecture-independent fuzzer for QEMU, requiring no firmware modification, was used to discover a previously unknown privilege escalation vulnerability.

\subsubsection{Techniques}

The core of Jetset is composed into three parts: \emph{specification}, \emph{peripheral inference and synthesis} and \emph{search strategy}. 
The \emph{specification} fed to Jetset consists of four parts, which must be attained via alternative means:

\begin{itemize}
	\item The \textbf{binary code} of the target, which must be read out of a physical flash or extracted from the target by some other means.
	\item The \textbf{memory layout} of the target, which specifies how physical devices are mapped into the memory of the device, and is used to determine which reads and writes are key to peripheral inference.
	\item The \textbf{entry point} of the target, e.g. where execution begins. In this sense, Jetset attempts a \emph{brute force} inference of the target, by beginning inference from the absolute start of execution. This stands in contrast to InteGreat, discussed later.
	\item A \textbf{goal address} to reach within the target. Jetset explores \emph{a single} execution path to a specific firmware state, and employs a \emph{single} search strategy to get to this target. This again will stand in contrast to InteGreat.
\end{itemize}

This specification is then used to begin the process of \emph{peripheral inference and synthesis}, the former of which consists of symbolically executing the firmware to infer what values should be returned by reads from device registers.
The symbolic execution uses a taint-tracking system build on top of the QEMU TCG intermediate representation, paired with the angr constraint solver, to determine which read values are necessary to achieve a particular execution trace.
This union between taint tracking and symbolic execution was noted in~\cite{schwartz2010all}.
Jetset and the popular SymQEMU~\cite{poeplau2021symqemu}, avoid supporting hundreds of essential TCG helper methods which capture important microarchitectural semantics, such as task switching, in order to make useful theoretical discoveries.
Four attempts to elegantly address this problem culminated in the later discovery and implementation of the InteGreat system.

\begin{figure}
\centering
%\includegraphics[width=8cm]{diagrams/distance_func.png}
\input{distance_func}
\caption{Context-sensitive distance from statement 5 (in first \texttt{foo} call) to statement 7 (of second \texttt{foo} call).}
\label{fig:distance_func}
\end{figure}

The \emph{synthesis stage} for peripherals recovers the specific model by making a call into angr's wrapper around the Z3 solver to find a concrete value that satisfies the constraints necessary to execute the desired program path.
For the purposes of finding a goal location in the firmware, Jetset naively applies just a single \emph{search strategy} to locate a target execution point, a combination of Tabu search, a variation of depth-first search guided by a distance function with a list of ``avoid'' states and a context-sensitive distance function generated by resolving the callgraph of dynamically resolved function calls during symbolic execution.
The latter is achieved by ``stitching'' the discovered call target address during the symbolic execution into the recovered control flow graph so far.
An overview of this process is given in Fig.~\ref{fig:distance_func}.

By adding the context of the child-call CFG as calls are resolved at runtime, Jetset takes into account the fact that the distance between two instructions in a program can depend on the calling context, i.e. the call-stack of the two instructions.
Because programs may modify their own callstack to perform returns to different locations, distance from the goal location is computed lazily from the actual stack during execution.
When Jetset is not able to resolve a path to the target due to indirect or runtime-calculated function pointers, it alternates between resolving branches as \emph{true} or \emph{false}, allowing it to escape from exploring the same loop resolution condition infinitely.

\subsubsection{Evaluation}

\input{data}

\begin{table*}
\small
\centering
\caption{Evaluation targets and summary statistics.}
\label{tab:targets}
\input{jetsettargets}
\vspace{\baselineskip} % Terrible, but out of time.
\end{table*}

Jetset's evaluation was dependent upon getting several firmware images into a steady state emulation, where the emulator would run without crashing.
The core targets for this evaluation were a Raspberry Pi 2, a single-board computer based on the Broadcom BCM2836 system-on-a-chip (SoC); a Collins Aerospace CMU-900, an electronic system used on many Boeing 737 aircraft, responsible for handling digital communications between the aircraft and ground stations with an AMD Am486, Intel 486-compatible processor; and a Schweitzer Engineering Laboratories SEL-751 feeder protection relay, used to protect power grid systems, leveraging a MCF54455, a 32-bit microprocessor implementing the ColdFire ISA.
The statistics on the emulation of these systems are given in Table~\ref{tab:targets}.

Details on the emulated and symbolically executed versions of the execution are given by the top and bottom portions of the table. 
Differences, in generally, are explanable due to the backtracking of symbolic execution when it hits an infinite loop (in these cases Jetset must re-execute code and take a different path), and due to slower inference-stage execution.
In the case of the Raspberry Pi, this led to an SD host controller command timeout, resulting in an error message and a register dump. 
During emulated execution with synthetic devices, the SD host controller initializes without a command timeout, thus, the executed blocks counts differ; however, the resulting emulation is resilient. 

While it was not addressed in the original publication, the testing of these systems also involved significant amounts of fuzz-testing using a custom built fuzzer that integrated AFL and QEMU, similar to FirmAFL~\cite{zheng2019firm}, but without requiring the modification of the target program.
It achieved this feat by performing a process-tree snapshot of the entire QEMU process while preserving speed by mounting QEMU's files into a RAM filesystem.
In the proposed dissertation, more detail on this fuzzer's implementation and the technical novelties would be provided---valuable due to the fact that the fuzzer has seen continued use after the paper's publication by a number of unaffiliated researchers.

The two targets of fuzzing were the Raspberry Pi and the CMU-900.
Both fuzzing sessions targeted the OS system call boundaries of Linux and VRTX, respectively.
While no novel vulnerabilities were found in Linux, all recovered fuzzing outputs were equivalent between the emulateed and physical versions of the Raspberry Pi.
The CMU-900, however, had significantly more successful results.
The AFL fuzzer found 2963 unique code paths during 200 hours of fuzzing, over 200 of which resulted in meaningful crashes.
One of these code paths, crashing on a function return, was bootstrapped into a privilege escalation vulnerability using a ROP chain by the author.

To validate this exploit on the physical device, for which the firmware version was different, the author had to build a ground truth QEMU emulation for the second firmware, and then write dataloading code to upload an handcrafted, shimmed version of the VRTX operating system which could inject the malicious system call at a realistic point in the physical device's execution.
This process was successful, and due to the complexity of relocating the shim code on the memory-constrained physical device while maintaining a true-to-reality execution of the system, required hundreds of lines of hand-written x86 assembly.

The discovery and crafting of this exploit would be further elucidated and detailed within the proposed thesis, and is valuable as it later led to the discovery of three remote denial-of-service vulnerabilities on the CMU-900 (unpublished), that cause the machine to crash due to maliciously crafted aircraft communication and reporting system (ACARS) messages.\footnote{Because ACARS messages also have a ``broadcast'' mode, these messages couldbe used to crash a large number of airplanes' CMU-900's simultaneously.}

\subsubsection{Discussion}

The Jetset work was a novel contribution to a young domain of firmware rehosting.
Thus, the techniques and methodologies adopted during symbolic execution and fuzzing had limitations. 
For one, the resulting emulation was not perfect.
However, a perfect emulation was not necessary for useful results.
While Jetset only explored and inferred constraints for a single execution path, the results of fuzzing these emulations led to a real vulnerability that was disclosed to the embedded system's vendor.

The current technical landscape of of symbolic execution and fuzzing on embedded systems is severely limited by support for microarchitectural abstractions, as, to the author's knowledge, all current embedded system fuzzers require modifications to the firmware under evaluation, and all symbolic executors fail to support all complex processor features, e.g. x86 task switching.
The proposed dissertation will address solutions to this limitation, both in the presentation of InteGreat and in detailing the construction of yAFL, the fuzzer Jetset used to discover the CMU-900 vulnerability.
